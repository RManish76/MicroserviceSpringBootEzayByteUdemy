*1* Dependency: Web, H2, JPA, Actuator, Lombok, validation

*2* Renamed the application.properties to application.yml
    yml work on identation like python.
    every . is replace with : and the text after : has to be in next line. And to pass the value
    instead of = in yml we just put : and a single space like below example
        In Properties
            spring.application.name=accounts
        In yml
            spring:
                application:
                    name: accounts

    Benifit if we have value like below in properties then you can note we are typing less words in yml.
        spring.datasource:url=jbdc:h2:mem:testdb
        spring.datasource:username=org.he.Driver
        
        In yml
            spring:
                datasource:
                    url: jbdc:h2:mem:testdb
                    username: org.he.Driver

    Also note that in yml each key is unique like spring should be used only one and all
    other method related to spring if we are calling it has to be below this spring only.
    We cannot initate another spring key in yml file.

    localhost:8080/h2-console   --> h2 console login page from browser if enable in yml/properties file.
    A form will come in h2 console which will auto populate some values from yml file make sure it matches
    the yml file.

*3* Creation of Schema for database
    Create a file with name schema.sql in resoruces folder where our application.properties or
    application.yml is located.
    In this schema.sql file we'll write query to create table.
        -- mistake, table & column need not to be quoted and if you want to do that then use either
        -- double quotes(") or brackets(`) this bracket symbol is below esc button in keyboard.
        -- Again best to not quote it. and single quote treated as string.


*4* Added BaseEntity Class.
    Here we have added four coulmn createdAt, createdBy, updatedAt, updatedBy.
    As we have seen that above 4 columns, we will use in most of entity class.
    So this entity class will be extended to other class and we need not manualy add these columns
    in every class.
        @MappedSuperclass //tells springJPA that this entity/model class will be used in all other entity/model class
        //the @MappedSuperclass annotation indicates to spring data jpa framework that this class is going
        //to act as a superclass for all my entites, wherever i'm trying to extend this base entity class
        @Column(updatable = false) //tells spring jpa that this column cannot be updated once value is inserted
        @Column(insertable = false) //insertable false means that whenever a new record is created this column should
        //not populate any value means it should be null. as its update column means we want value here when
        //only the record is updated

*5*Lombok warning when using @Data in customer class and extending to BaseEntity class which also have @Data
 warning: Generating equals/hashCode implementation but without a call to superclass, even though this class does not extend java.lang.Object.
             If this is intentional, add '@EqualsAndHashCode(callSuper=false)' to your type.Java(0)

    @Data has @Getter / @Setter, @ToString, @EqualsAndHashCode <-- This is the culprit! and @RequiredArgsConstructor

    Now to equal has annotation, the Lombok is showing warning to consider unique records should
        it consider combine records from parnet and child both or should it consider the child only
        Idealy it should be child only as here we only care about customer id unique not the created at or by.
     By Gemini   
        Concept	Your Understanding	Reality
        Logic	"Should I look at parent variables or not?"	Correct. That is exactly what Lombok is asking.
        Responsibility	"Lombok is checking for unique records."	Incorrect. Lombok is generating the equals() method so Java Lists/Sets work in memory.
        The Warning	"Why does Lombok care?"	Because @Data generates equals(). If you don't want equals(), use @Getter and @Setter instead of @Data.

        @EqualsAndHashCode(callSuper = false) will tell Lombok to consider only child not parent+child

*6* Created DTO(Data Transfer object) class 
    These class is responsibil for the variables/column which'll be sent to customer or
    recive from customer.
    we have done this because if we made any change in our database/entity class it'll
    not affect the api points which was exposed to clients.
    And also it decouples the entity class from the exposed rest call.
    And also lets say if client need combine data customer and accounts then we can't ask client
    make two rest call for that so in that case we can create combined DTOs for the client.
    Currently we'll not create combined DTO class will do it later.

    Created more DTO called ResponseDto for sending response for rest call and also created
    ErrorResponseDto class to send error details for restcall if rest call error out.

*7* Creation of API points

    Created a static file. The fields/variables will be used to return response.
    We have made the constructor of this class private so that no one can  use this class for
    any method or businees Logic.
    All the fileds/variables in this file are static and final means we can use it with class name only
    no need to create object of this class.

    added accounts service interface and accountService implementation class in service package.

    added AccountsMapper class which will be responsibil to map values between entity to DTO and vice-versa
    added CustomerMapper class which will be responsibil to map values between entity to DTO and vice-versa
    //we have libraries available online like modelmapper, mapstruct to this automatic mapping but not recognized
    //also we can see it's not available in spring initiliazer

    Modified AccountsServiceImpl which will talk to mapper to set and get values as per rest request.
        I think The difference between IAccountsService and AccountsServiceImpl is that the interface will 
        dictate the methods and Impl will implement it.

    Created exception package where we'll define our custom exceptions.
        for now only one deifned for if customer already exist (using same mobile number)

        Now for these exception we need to check customer already exist with given mobile number
        and since mobile number is not present we need to write DerivedNamedMethod ie findByMobileNumber
        in repo class.

    Created GlobalExceptionHandler file to handle all kind of exceptions in one place.
        for example if an exception occurent in accounts servie then it'll goto accountController
        and we need to catch the excpetion there and handle it.
        Simlarly if we have 5 different services and controllers for them. then we might endup
        wirtting same type of exception catch in 5 different controllers.
        Here we are creating a global exception handler in which we'll handle all the exception for
        all controllers

*8* Added Read Api using mobile number
    Created api point using which client can pass mobile number to find the customer and account related to 
    that mobile number.
    mdified the customerdto to store accountdto as well. so that when client sends a get request
    then using only customerdto we can send detials of customer and accounts from a single dto.
    We can create sepreate dto as well but since fields were too few we added in customerdto.