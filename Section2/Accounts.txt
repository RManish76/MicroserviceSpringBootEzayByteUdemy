*1* Dependency: Web, H2, JPA, Actuator, Lombok, validation

*2* Renamed the application.properties to application.yml
    yml work on identation like python.
    every . is replace with : and the text after : has to be in next line. And to pass the value
    instead of = in yml we just put : and a single space like below example
        In Properties
            spring.application.name=accounts
        In yml
            spring:
                application:
                    name: accounts

    Benifit if we have value like below in properties then you can note we are typing less words in yml.
        spring.datasource:url=jbdc:h2:mem:testdb
        spring.datasource:username=org.he.Driver
        
        In yml
            spring:
                datasource:
                    url: jbdc:h2:mem:testdb
                    username: org.he.Driver

    Also note that in yml each key is unique like spring should be used only one and all
    other method related to spring if we are calling it has to be below this spring only.
    We cannot initate another spring key in yml file.

    localhost:8080/h2-console   --> h2 console login page from browser if enable in yml/properties file.
    A form will come in h2 console which will auto populate some values from yml file make sure it matches
    the yml file.

*3* Creation of Schema for database
    Create a file with name schema.sql in resoruces folder where our application.properties or
    application.yml is located.
    In this schema.sql file we'll write query to create table.
        -- mistake, table & column need not to be quoted and if you want to do that then use either
        -- double quotes(") or brackets(`) this bracket symbol is below esc button in keyboard.
        -- Again best to not quote it. and single quote treated as string.


*4* Added BaseEntity Class.
    Here we have added four coulmn createdAt, createdBy, updatedAt, updatedBy.
    As we have seen that above 4 columns, we will use in most of entity class.
    So this entity class will be extended to other class and we need not manualy add these columns
    in every class.
        @MappedSuperclass //tells springJPA that this entity/model class will be used in all other entity/model class
        //the @MappedSuperclass annotation indicates to spring data jpa framework that this class is going
        //to act as a superclass for all my entites, wherever i'm trying to extend this base entity class
        @Column(updatable = false) //tells spring jpa that this column cannot be updated once value is inserted
        @Column(insertable = false) //insertable false means that whenever a new record is created this column should
        //not populate any value means it should be null. as its update column means we want value here when
        //only the record is updated

*5*Lombok warning when using @Data in customer class and extending to BaseEntity class which also have @Data
 warning: Generating equals/hashCode implementation but without a call to superclass, even though this class does not extend java.lang.Object.
             If this is intentional, add '@EqualsAndHashCode(callSuper=false)' to your type.Java(0)

    @Data has @Getter / @Setter, @ToString, @EqualsAndHashCode <-- This is the culprit! and @RequiredArgsConstructor

    Now to equal has annotation, the Lombok is showing warning to consider unique records should
        it consider combine records from parnet and child both or should it consider the child only
        Idealy it should be child only as here we only care about customer id unique not the created at or by.
     By Gemini   
        Concept	Your Understanding	Reality
        Logic	"Should I look at parent variables or not?"	Correct. That is exactly what Lombok is asking.
        Responsibility	"Lombok is checking for unique records."	Incorrect. Lombok is generating the equals() method so Java Lists/Sets work in memory.
        The Warning	"Why does Lombok care?"	Because @Data generates equals(). If you don't want equals(), use @Getter and @Setter instead of @Data.

        @EqualsAndHashCode(callSuper = false) will tell Lombok to consider only child not parent+child

*6* Created DTO(Data Transfer object) class 
    These class is responsibil for the variables/column which'll be sent to customer or
    recive from customer.
    we have done this because if we made any change in our database/entity class it'll
    not affect the api points which was exposed to clients.
    And also it decouples the entity class from the exposed rest call.
    And also lets say if client need combine data customer and accounts then we can't ask client
    make two rest call for that so in that case we can create combined DTOs for the client.
    Currently we'll not create combined DTO class will do it later.

    Created more DTO called ResponseDto for sending response for rest call and also created
    ErrorResponseDto class to send error details for restcall if rest call error out.

*7* Creation of API points

    Created a static file. The fields/variables will be used to return response.
    We have made the constructor of this class private so that no one can  use this class for
    any method or businees Logic.
    All the fileds/variables in this file are static and final means we can use it with class name only
    no need to create object of this class.

    added accounts service interface and accountService implementation class in service package.

    added AccountsMapper class which will be responsibil to map values between entity to DTO and vice-versa
    added CustomerMapper class which will be responsibil to map values between entity to DTO and vice-versa
    //we have libraries available online like modelmapper, mapstruct to this automatic mapping but not recognized
    //also we can see it's not available in spring initiliazer

    Modified AccountsServiceImpl which will talk to mapper to set and get values as per rest request.
        I think The difference between IAccountsService and AccountsServiceImpl is that the interface will 
        dictate the methods and Impl will implement it.

    Created exception package where we'll define our custom exceptions.
        for now only one deifned for if customer already exist (using same mobile number)

        Now for these exception we need to check customer already exist with given mobile number
        and since mobile number is not present we need to write DerivedNamedMethod ie findByMobileNumber
        in repo class.

    Created GlobalExceptionHandler file to handle all kind of exceptions in one place.
        for example if an exception occurent in accounts servie then it'll goto accountController
        and we need to catch the excpetion there and handle it.
        Simlarly if we have 5 different services and controllers for them. then we might endup
        wirtting same type of exception catch in 5 different controllers.
        Here we are creating a global exception handler in which we'll handle all the exception for
        all controllers

*8* Added Read Api using mobile number
    Created api point using which client can pass mobile number to find the customer and account related to 
    that mobile number.
    mdified the customerdto to store accountdto as well. so that when client sends a get request
    then using only customerdto we can send detials of customer and accounts from a single dto.
    We can create sepreate dto as well but since fields were too few we added in customerdto.

*8* Added Update API
    Client can update everything except account number.
    Client has to pass accountDto details with customerDto to process successfull update.
    If accountDto is missing or account number it self is missing we are handling that thorugh
    exception.
    In current update code in AccountsServiceImpl, we are not checking if same mobile number already exist for
    any other customer like we are doing in createAccount, just simply updating it.

*9* Delete API
    deleteById method is present in CurdRepository which deletes a row based on primary key.

    similary we can delete an account by its primary key, which is account number.
    but to do that we need fire a query using customerId to get accountnumber and then execute delete method.
    Instead we'll do deleteByCustomerId in which we will pass customerId to delete the account.
    Since CustomerId is not primary key in accounts table we need to write a method to delete it using CustomerId
    and since its only simple single column execution jpa will take care of it, we need to just write the method.

    Also in that method we are adding two annotations @Modifying and @Transactional
        @Transactional //below query/method should be Transactional ie it 
            should be able to roleback automatically if failuer occured in middle of execution
        @Modifying  //tells spring below query/method will modify the data
    
    When we use primary key for delete or modify, spring internally take cares of Transactional and Modifying

*10* Additon of exception in GlobalExceptionHandler
    Added the exception method with other custome methods.
    Whenever a exception will occur spring will first look is there any custom exception deifned
    for that exception. If yes then it'll use that exception method else it'll exceute the execiption
    method for all other exception.

*11* validation
    While creating the project at spring initiliazer we added a dependency
    "Validation I/O" and in our pom file it is present as
    "spring-boot-starter-validation"
    This dependency contains all the annotations and libraries which help us enforse validation
    on input data which we recive from the clients.

    We'll start with DTO's.
    Whatever data we recive from the clients will get converted int DTOs.
    So these DTOs are going to hold the data that we re going to receive from clients, which means
    my spring boot has to perform the validations on the data stored inside the object of this
    CustomerDto or any other DTO like AccountsDto.
    the package name is import jakarta.validation.constraints....;
    we have used few annotation like below, which check if received value as per the validation or not else send this message as response.

        @NotEmpty(message = "Name can not be a null or empty") //tells to spring validatiion it cannot be empty. If empty recived return the messsage
        @Size(min = 5, max = 30, message = "The lenth of the customer name should be between 5 and 30")
        @Email(message = "Email address should be a vaild value") //check email format like @, domain format etc
        @Pattern(regexp = "(^$|[0-9]{10})",message = "Mobile number must be 10 digits") 
                //using pattern annotation we can define pattern validatiion
                //and we have used regexp to define the pattern.

    Now we need to goto place where we are using these DTOs ie the place where we are recving the input
     the controllers
        @Validated //tells spring that validation should be perfromed in this classs
        @Valid //@Valid tells that recived body is valid or not as per the DTOs and validAnnotation at DTO

        Since at /fetch and /delete api point we are not reciveing body in request we cannot use 
        @vaild annotation.
        So we'll directly metion the validations like we did in DTOs just after @RequestParam like below

            @GetMapping("/fetch")
            public ResponseEntity<CustomerDto> fetchAccountDetails(@RequestParam 
                                                        @Pattern(regexp = "(^$|[0-9]{10})",message = "Mobile number must be 10 digits")
                                                        String mobileNumber){

    Now we are doing validation and when validation failed we are also returning message as well.
    But we are not accepting that msg anywhere to send to client.
    And as we have seen that if any kind issue we are handling thorugh exception and global exception
    hence we'll also accept the message in global exception and return it.
    And to do that first we'll extend GlobalExceptionHandler from ResponseEntityExceptionHandler
    The ResponseEntityExceptionHandler has a method which will help us to get validation failuer 
    and msgs.
    the method is protected ResponseEntity<Object> handleMethodArgumentNotValid
    we create a map where we'll store the key as field which failed the validatiion and
        value as message of validation failuer
    then created a list which collecting all validation occured then form this list
    we are pull the field and msg and storing it in map then returning the map to client.

*12* Audit columns
        We have included column createdAt, createdBy, updatedAt, updatedBy.
        Till know we were not taking care of these columns.
        Also till know we have not written a single query for other features.
        Similarly for these audit columns we can handover the responsebility to Update
        these column to Spring JPA by using some annotations.
        So we'll update few annotations in BaseEntity.java as this class contains our
        audit columns.
            @CreatedDate, @CreatedBy,@LastModifiedDate, @LastModfiedBy we have added these
        annotations.
        Using these annotation we are telling to spring framework. Whenever you see these fields inside
        a table or an entity, please make sure you are updating the date time based upon when the record is
        being updated or inserted. The same applies for last modifed date as well and with the help of
        createBy and last modified by, we are telling to the Spring data JPA framework like who is tryping
        create or update the reocrds inside the database table.

        Now the time can be picked from server time which spring will do but what about createdBy and
        updatedBy. For that we need to define a class which will help us to identify the user.
        For now we'll hardcord the user and when we implement the spring security will make it dynamic.
        We'll create new package called audit and inside that package we will create a file called
        AuditAwareImpl.java
        We'll implement AuditorAware<DataType> interface in our class and override the method which will
        get us the current auditor(hardcorded).
        After doing that we need to mention an annotation @EntityKisteners(AuditingEntityListener.class)
        at BaseEntity.java the AuditingEntityListener.class is a class present in spring data framework.

        Once that done we need to goto AccountsApplication.java which is our application or root file.
        there we need to enable Auditing and pass the audit class's bean which we created.
            @EnableJpaAuditing(auditorAwareRef="auditAwareImpl") is the annotation we need to put there.
        @EnableJpaAuditing tell to enable the audting and using param auditorAwareRef we passing the bean of
        the audit class which need to be used.

        After doing this we can remove the hardcorded value which we created for createdby, createdat 
        etc in AccountsServiceImpl

*13* API Documentation

        For API documentation we are going to use a dependency from springdoc.org (not offical from springInitalizer)
        We just need to add the dependency present in there and refresh the Maven then run the application.
        Affter running we need to go http://localhost:8080/swagger-ui/index.html 
        There we'll able to see all of our api which we created documented as per Swagger convention.

        This dependency scans the project and automatically create the documentation for us.

        After doing this we'll abel to see the documentation of our API endpoints.
        But there's a issue its showing our technical/object name in documentation like controllers, dto etc
        also response/request payload it's showing "string" as input instead of any example value.
        Hence we need to do some modification to make it look more professional.

        Lets start with header.
        1. Currently in big bold letter in documentation page "OpenAPI definiion" is writter we need
            modify that
            For that we need to add another annotation to our root/AccountsApplication.java/springboot main class
            file.
            We are adding @OpenAPIDefinition annotation like below wehre info is param like below
                            @OpenAPIDefinition(
                                info = @Info(
                                    title = "Accounts microservice REST API Documentation",
                                    description = "EzayBank Accounts microservice REST API Documentation",
                                    version = "v1",
                                    contact = @Contact(
                                        name = "Madan Reddy",
                                        email = "tutor@eazybytes.com",
                                        url = "https://www.eazybytes.com"
                                    ),
                                    license = @License(
                                        name = "Apache 2.0",
                                        url = "http://licenceDetailUrl.com"
                                    )
                                ),
                                externalDocs = @ExternalDocumentation(
                                    description = "EazyBank Accounts microservice REST API Documentation",
                                    url = "https://www.eazybytes.com/swagger-ui.html"
                                )
                            )
        2. Now we'll the technical details which are showing like controller and dtos 
            We have only one controller we can have mutlitple controllers.
            to show different name for controllers we need to got to each controllerclass add annotation
            @Tag which from springdoc only to class and then inside this annotation we can pass the
            details related to controller such as name, description etc. like below
                    @Tag(
                        name = "CRUD REST APIs for Accounts in EazyBank",
                        description = "CRUD REST APIs in EazyBank to CREATE, UPDATE, FETCH AND DELETE account details"
                    )
                    @RestController
                    @RequestMapping(path = "/api", produces = {MediaType.APPLICATION_JSON_VALUE})
                    // path -> all api call will start with domain/api/...   and mediatype tells what format of data will be used which is json
                    @AllArgsConstructor
                    @Validated //tells spring that validation should be perfromed in this classs
                    public class AccountsController {
        
        3. Now we'll change deails related to api endpoints.
            We have defined api endpoints in the controller as methods.
            So we will add annotations to methods like below
                    @Operation(
                        summary = "Delete Account & Customer Details REST API",
                        description = "REST API to delete Customer & Account details based on a mobile number"
                    )
                    @ApiResponses({
                        @ApiResponse(
                            responseCode = "200",
                            description = "HTTP Status OK"
                        ),
                        @ApiResponse(
                            responseCode = "500",
                            description = "HTTP Status Internal Server Error"
                        )
                    })
        
        4. Now we'll add details related to request/response example.
            Since request/response example is related DTO hence now we need to add annotations
            related OpenAPI doc in DTO classes
            We need add annotation at table/class level also at field level as well.
            Note: By default it picks name from the code. so if we give name OpenAPI doc will use that
                    else it'll use name which we have given in the code to class and field.
                
            We have added Schema to each dto at class as well as field level.
                    @Schema(
                        name = "Customer",
                        description = "Schema to hold Customer and Account information"
                    )

        5. Previously ErrorResponseDto Schema at bottom of api doc was not showing.
            where as other DTOs were showing.
            It's because other DTOs were going through the controller which catching these DTOs
            but the ErrorResponseDto is going to GlobalExceptionHandler instead of controller.
                so in controller in update api we dedicately included the ErrorResponseDto class so
                that OpenAPI doc know about it and include it.